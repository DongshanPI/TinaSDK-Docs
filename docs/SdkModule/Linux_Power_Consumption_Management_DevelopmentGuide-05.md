## 5 FAQ 问题及处理方法

### 5.1 系统无法休眠

这种问题一般是由于使用了wakelock 机制，在休眠前判断系统状态时，系统存在wakelock ,最终导致系统无法进入休眠流程。

处理：
• 一般先通过cat /sys/power/wake_lock 来确认是否存在wakelock；
• 注意：如果连接了usb，则usb driver 会申请wakelock，但该用户空间节点无法读出来。
• 如果存在usb 链接，拔掉usb；存在wakelock, 则可以通过cat /sys/power/wake_unlock 节点来取消该wakelock；
• 然后再次尝试使用上文的休眠脚本示例休眠；
• 另外，也可以直接执行echo mem > /sys/power/state在不释放wakelock 的情况下，强制休眠，来验证一些这个问题。注: 我们一般建议此操作仅用于临时调试，因为该操作会导致wakelock没有效果。
• 最终，需要找出设置wakelock 的模块，跟本上解决问题。

### 5.2 系统休眠后直接重启或延时几秒后重启

这种问题一般是由于休眠过程中，某一驱动模块oops 卡死，导致触发保护机制重启，或休眠后系统掉电异常，例如rtc 的电也掉了导致。

对于前者，可以使能休眠唤醒日志，确认是哪一模块，然后找相关同事协助处理；临时测试，也可以先尝试去掉该驱动模块；

```
# 使能休眠唤醒所有的日志

echo 1 > /sys/power/pm_print_times;
echo N > /sys/module/printk/parameters/console_suspend;
echo Y > /sys/module/kernel/parameters/initcall_debug;
echo 8 > /proc/sys/kernel/printk;
```

对于后者，先排除前者问题后，可以用万用表或示波器抓取一些关键电源的休眠状态，如vccrtc,vdd-cpu, vdd-sys, vcc-pll 等，然后与正常机器比较，或找相关硬

件同事确认。

也有一些其他原因，如内存踩踏等，可导致此现象，这里不展开说明。

### 5.3 休眠后系统无法唤醒

这种问题是最常见的休眠唤醒问题，导致该现象的问题原因也比较多，包括但不限于，唤醒源配置不对，内核卡死但未触发重启，cpus/dsp/optee 等卡死，内存

踩踏或使用超出范围内存，dram 不正常，系统硬件问题。所以我们一般会建议客户通过以下流程逐步收集一些有用信息，如果发现问题跟因客户可根据情况自行

处理，若未发现跟因也可提供到我们进一步排查，可大大节省排查时间：

• 使用powerkey，rtc 等默认唤醒源唤醒，排除由于唤醒源配置导致的无法唤醒；

• 使能日志，排除由于系统卡死导致，导致休眠没有完成而无法唤醒；

• 与正常机器对比，回退部分提交，确认问题大致什么时间以及什么模块引入；

• 通过/sys/power/pm_test 节点，执行不同深度的休眠，确认问题点出现在休眠唤醒流程的哪个阶段；

• 如果echo core > /sys/power/pm_test 后仍不可以唤醒，说明问题大概率出现kernel 模块中，否则问题可能在cpus/dsp/optee 等阶段；

• 通过观察cpus，dsp，optee 串口日志，确认其是否存活。

• 通过仪器测量各路电源状态，以及在休眠流程中对一些寄存器（时钟、电源、IO 状态）值进行确认，细化问题点；

• 如果上述都不能找到有效点，可以联系处理，并尽可能提供相关信息。